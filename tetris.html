<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mobile Tetris</title>
    <style>
        /* --- CSS STYLES --- */
        body {
            background-color: #333;
            color: #fff;
            font-family: sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            user-select: none; /* Prevent selection on mobile */
            -webkit-tap-highlight-color: transparent; /* Remove tap highlight */
        }

        #game-container {
            text-align: center;
            padding: 20px;
        }

        #tetris-canvas {
            border: 4px solid #fff;
            background-color: #000;
            display: block;
            margin: 0 auto 10px;
        }

        #controls {
            display: grid;
            grid-template-areas:
                ". rotate ."
                "left down right";
            gap: 10px;
            max-width: 300px;
            margin: 0 auto;
        }

        #left-btn { grid-area: left; }
        #rotate-btn { grid-area: rotate; }
        #right-btn { grid-area: right; }
        #down-btn { grid-area: down; }

        #controls button, #start-btn {
            padding: 15px;
            font-size: 20px;
            font-weight: bold;
            background-color: #555;
            color: white;
            border: none;
            border-radius: 5px;
            touch-action: manipulation; /* Improves mobile responsiveness */
        }

        #controls button:active, #start-btn:active {
            background-color: #777;
        }

        #score {
            margin: 15px 0;
            font-size: 1.2em;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <h1>Mobile Tetris üß±</h1>
        <canvas id="tetris-canvas"></canvas>
        <div id="controls">
            <button id="left-btn">‚Üê</button>
            <button id="rotate-btn">‚Üª</button>
            <button id="right-btn">‚Üí</button>
            <button id="down-btn">‚Üì</button>
        </div>
        <p id="score">Score: 0</p>
        <button id="start-btn">Start Game</button>
    </div>

    <script>
        // --- JAVASCRIPT LOGIC ---
        const canvas = document.getElementById('tetris-canvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const startBtn = document.getElementById('start-btn');

        // Game constants
        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 30; // Blocks are 30x30 pixels
        canvas.width = COLS * BLOCK_SIZE;
        canvas.height = ROWS * BLOCK_SIZE;

        // Tetromino shapes (matrix) and colors
        const SHAPES = [
            // I piece
            [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]],
            // J piece
            [[2, 0, 0], [2, 2, 2], [0, 0, 0]],
            // L piece
            [[0, 0, 3], [3, 3, 3], [0, 0, 0]],
            // O piece
            [[4, 4], [4, 4]],
            // S piece
            [[0, 5, 5], [5, 5, 0], [0, 0, 0]],
            // T piece
            [[0, 6, 0], [6, 6, 6], [0, 0, 0]],
            // Z piece
            [[7, 7, 0], [0, 7, 7], [0, 0, 0]],
        ];
        const COLORS = [
            '#000', // Empty (index 0)
            '#00FFFF', // I - Cyan (index 1)
            '#0000FF', // J - Blue (index 2)
            '#FFA500', // L - Orange (index 3)
            '#FFFF00', // O - Yellow (index 4)
            '#00FF00', // S - Green (index 5)
            '#800080', // T - Purple (index 6)
            '#FF0000'  // Z - Red (index 7)
        ];

        // Game state
        let board = [];
        let score = 0;
        let gameOver = true;
        let currentPiece;
        let nextPiece;
        let lastTime = 0;
        let dropCounter = 0;
        let dropInterval = 1000; // Drop every 1000ms (1 second)
        let requestId;

        // --- Game Initialization ---

        function createBoard() {
            return Array.from({ length: ROWS }, () => new Array(COLS).fill(0));
        }

        function getRandomPiece() {
            const randomIndex = Math.floor(Math.random() * SHAPES.length);
            const shape = SHAPES[randomIndex];
            const colorId = randomIndex + 1; // 1-7 for actual colors
            
            // Pieces start above the board, centered
            return {
                matrix: shape,
                x: Math.floor((COLS / 2) - (shape[0].length / 2)),
                y: -shape.length, // Start off-screen
                colorId: colorId
            };
        }

        function startGame() {
            score = 0;
            scoreElement.textContent = `Score: ${score}`;
            board = createBoard();
            gameOver = false;
            currentPiece = getRandomPiece();
            nextPiece = getRandomPiece();
            startBtn.textContent = 'Restart Game';
            
            // Start the game loop
            if (requestId) cancelAnimationFrame(requestId);
            requestId = requestAnimationFrame(gameLoop);
        }

        // --- Drawing Functions ---

        function drawBlock(x, y, colorId) {
            if (colorId === 0) return; // Don't draw empty blocks
            ctx.fillStyle = COLORS[colorId];
            ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
            
            // Simple block outline for better look
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
        }

        function drawBoard() {
            for (let y = 0; y < ROWS; y++) {
                for (let x = 0; x < COLS; x++) {
                    drawBlock(x, y, board[y][x]);
                }
            }
        }

        function drawPiece(piece) {
            piece.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        drawBlock(piece.x + x, piece.y + y, piece.colorId);
                    }
                });
            });
        }

        // --- Collision and Movement ---

        function checkCollision(newX, newY, matrix) {
            for (let y = 0; y < matrix.length; y++) {
                for (let x = 0; x < matrix[y].length; x++) {
                    if (matrix[y][x] !== 0) {
                        const boardX = newX + x;
                        const boardY = newY + y;
                        
                        // Check if hit wall or floor
                        if (boardX < 0 || boardX >= COLS || boardY >= ROWS) {
                            return true;
                        }
                        
                        // Check if hit an existing block (only if it's on the board)
                        if (boardY >= 0 && board[boardY][boardX] !== 0) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function pieceDrop() {
            if (checkCollision(currentPiece.x, currentPiece.y + 1, currentPiece.matrix)) {
                mergePiece();
                clearLines();
                
                currentPiece = nextPiece;
                nextPiece = getRandomPiece();
                
                // Check for Game Over (new piece immediately collides)
                if (checkCollision(currentPiece.x, currentPiece.y, currentPiece.matrix)) {
                    gameOver = true;
                    alert(`Game Over! Final Score: ${score}`);
                    startBtn.textContent = 'Play Again';
                }
            } else {
                currentPiece.y++;
            }
        }

        function movePiece(dir) {
            if (gameOver) return;
            const newX = currentPiece.x + dir;
            if (!checkCollision(newX, currentPiece.y, currentPiece.matrix)) {
                currentPiece.x = newX;
            }
        }

        function rotateMatrix(matrix) {
            // Transpose matrix
            const N = matrix.length;
            let newMatrix = matrix.map((row, i) => row.map((val, j) => matrix[j][i]));
            
            // Reverse rows
            return newMatrix.map(row => row.reverse());
        }

        function rotatePiece() {
            if (gameOver) return;
            const rotated = rotateMatrix(currentPiece.matrix);
            
            // Simple wall kick attempt for better feel
            let offset = 1;
            while(checkCollision(currentPiece.x, currentPiece.y, rotated)) {
                currentPiece.x += offset;
                offset = -(offset + (offset > 0 ? 1 : -1));
                if (offset > currentPiece.matrix[0].length) { // Max kick attempts
                    currentPiece.x = currentPiece.x - offset; // Restore original x
                    return;
                }
            }
            currentPiece.matrix = rotated;
        }

        function mergePiece() {
            currentPiece.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        // Ensure y is a valid board index (only visible blocks)
                        if (currentPiece.y + y >= 0) {
                            board[currentPiece.y + y][currentPiece.x + x] = currentPiece.colorId;
                        }
                    }
                });
            });
        }

        function clearLines() {
            let linesCleared = 0;
            for (let y = ROWS - 1; y >= 0; ) {
                if (board[y].every(value => value !== 0)) {
                    // Line is full, clear it and drop everything above
                    for (let i = y; i > 0; i--) {
                        board[i] = board[i - 1];
                    }
                    board[0] = new Array(COLS).fill(0); // Top line is now empty
                    linesCleared++;
                    // Don't increment y because the new line has dropped down into this row
                } else {
                    y--; // Check the next row up
                }
            }
            
            // Score calculation (Standard Tetris scoring)
            if (linesCleared > 0) {
                const points = [0, 40, 100, 300, 1200];
                score += points[linesCleared];
                scoreElement.textContent = `Score: ${score}`;
                
                // Make the game faster every time score increases
                // dropInterval = Math.max(100, 1000 - Math.floor(score / 500) * 100);
            }
        }

        // --- Game Loop ---
        function gameLoop(time = 0) {
            const deltaTime = time - lastTime;
            lastTime = time;

            dropCounter += deltaTime;
            if (dropCounter > dropInterval) {
                pieceDrop();
                dropCounter = 0;
            }

            // Drawing
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height); // Clear screen

            drawBoard();
            drawPiece(currentPiece);
            
            // Only continue if game is not over
            if (!gameOver) {
                requestId = requestAnimationFrame(gameLoop);
            }
        }

        // --- Event Listeners (Mobile Controls) ---

        document.getElementById('left-btn').addEventListener('click', () => movePiece(-1));
        document.getElementById('right-btn').addEventListener('click', () => movePiece(1));
        document.getElementById('rotate-btn').addEventListener('click', rotatePiece);
        document.getElementById('down-btn').addEventListener('click', () => {
            // Instant drop down (slam)
            if (gameOver) return;
            while (!checkCollision(currentPiece.x, currentPiece.y + 1, currentPiece.matrix)) {
                currentPiece.y++;
            }
            dropCounter = dropInterval; // Force a drop/merge on next loop
        });

        startBtn.addEventListener('click', startGame);

        // Initialize the board for the first time
        board = createBoard();
        drawBoard();
    </script>
</body>
</html>